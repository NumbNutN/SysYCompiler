### 后端代码执行流程

+ 计算当前函数的栈帧大小
  + 遍历到新的define变量：将变量尺寸添加到总大小
  + 遍历到新的数组：将数组指针的尺寸添加到总大小；（不是参数时）将数组的长度也添加到总大小
+ 初始化函数栈帧
  + 新建栈空间链表
+ 设置函数栈区
  + 堆入FP LR
  + 调整SP和FP的位置（至局部变量区基地址）
+ 将寄存器分配的结果转为变量信息表
  + 对于参数（不会出现在表达式左侧）分配寄存器和内存
  + 对于出现在表达式左侧的变量 分配寄存器和内存
  + 对于出现在表达式左侧的数组 是参数则忽略  是局部数组则分配寄存器或内存
+ 统计当前函数使用的所有通用寄存器并作为现场保护
  + 统计并堆通用寄存器R4-R12
+ 为数组分配内存单元
  + 为数组分配内存单元
  + 生成指令将数组的基地址存放在为数组分配的寄存器或内存单元中（好像可以在allocate中完成）
+ 使SP之前偏移到局部变量基地址的部分生效
+ R7与SP保持一致
+ 将参数传递到为其分配的寄存器或地址
+ 翻译函数主体
+ translate_allocate_instruction()
  + 会在数组为参数的时候，矫正参数值
+ 恢复局部作用域并更新SP指针
+ 恢复现场
+ 恢复FP和LR